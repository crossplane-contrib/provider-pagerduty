// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type OrchestrationUnroutedCatchAllActionsExtractionInitParameters struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsExtractionObservation struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsExtractionParameters struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	// +kubebuilder:validation:Optional
	Target *string `json:"target" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	// +kubebuilder:validation:Optional
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsInitParameters struct {

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	Extraction []OrchestrationUnroutedCatchAllActionsExtractionInitParameters `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	Variable []OrchestrationUnroutedCatchAllActionsVariableInitParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsObservation struct {

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	Extraction []OrchestrationUnroutedCatchAllActionsExtractionObservation `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	Suppress *bool `json:"suppress,omitempty" tf:"suppress,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	Variable []OrchestrationUnroutedCatchAllActionsVariableObservation `json:"variable,omitempty" tf:"variable,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsParameters struct {

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	// +kubebuilder:validation:Optional
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	// +kubebuilder:validation:Optional
	Extraction []OrchestrationUnroutedCatchAllActionsExtractionParameters `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	// +kubebuilder:validation:Optional
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	// +kubebuilder:validation:Optional
	Variable []OrchestrationUnroutedCatchAllActionsVariableParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsVariableInitParameters struct {

	// The name of the variable
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Only regex is supported
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The Regex expression to match against. Must use valid RE2 regular expression syntax.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsVariableObservation struct {

	// The name of the variable
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Only regex is supported
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The Regex expression to match against. Must use valid RE2 regular expression syntax.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OrchestrationUnroutedCatchAllActionsVariableParameters struct {

	// The name of the variable
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// Only regex is supported
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// The Regex expression to match against. Must use valid RE2 regular expression syntax.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type OrchestrationUnroutedCatchAllInitParameters struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	Actions []OrchestrationUnroutedCatchAllActionsInitParameters `json:"actions,omitempty" tf:"actions,omitempty"`
}

type OrchestrationUnroutedCatchAllObservation struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	Actions []OrchestrationUnroutedCatchAllActionsObservation `json:"actions,omitempty" tf:"actions,omitempty"`
}

type OrchestrationUnroutedCatchAllParameters struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	// +kubebuilder:validation:Optional
	Actions []OrchestrationUnroutedCatchAllActionsParameters `json:"actions" tf:"actions,omitempty"`
}

type OrchestrationUnroutedInitParameters struct {

	// the catch_all actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	CatchAll []OrchestrationUnroutedCatchAllInitParameters `json:"catchAll,omitempty" tf:"catch_all,omitempty"`

	// The Event Orchestration to which this Unrouted Orchestration belongs to.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-pagerduty/apis/namespaced/event/v1alpha1.Orchestration
	EventOrchestration *string `json:"eventOrchestration,omitempty" tf:"event_orchestration,omitempty"`

	// Reference to a Orchestration in event to populate eventOrchestration.
	// +kubebuilder:validation:Optional
	EventOrchestrationRef *v1.NamespacedReference `json:"eventOrchestrationRef,omitempty" tf:"-"`

	// Selector for a Orchestration in event to populate eventOrchestration.
	// +kubebuilder:validation:Optional
	EventOrchestrationSelector *v1.NamespacedSelector `json:"eventOrchestrationSelector,omitempty" tf:"-"`

	// An Unrouted Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	Set []OrchestrationUnroutedSetInitParameters `json:"set,omitempty" tf:"set,omitempty"`
}

type OrchestrationUnroutedObservation struct {

	// the catch_all actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	CatchAll []OrchestrationUnroutedCatchAllObservation `json:"catchAll,omitempty" tf:"catch_all,omitempty"`

	// The Event Orchestration to which this Unrouted Orchestration belongs to.
	EventOrchestration *string `json:"eventOrchestration,omitempty" tf:"event_orchestration,omitempty"`

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// An Unrouted Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	Set []OrchestrationUnroutedSetObservation `json:"set,omitempty" tf:"set,omitempty"`
}

type OrchestrationUnroutedParameters struct {

	// the catch_all actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	// +kubebuilder:validation:Optional
	CatchAll []OrchestrationUnroutedCatchAllParameters `json:"catchAll,omitempty" tf:"catch_all,omitempty"`

	// The Event Orchestration to which this Unrouted Orchestration belongs to.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-pagerduty/apis/namespaced/event/v1alpha1.Orchestration
	// +kubebuilder:validation:Optional
	EventOrchestration *string `json:"eventOrchestration,omitempty" tf:"event_orchestration,omitempty"`

	// Reference to a Orchestration in event to populate eventOrchestration.
	// +kubebuilder:validation:Optional
	EventOrchestrationRef *v1.NamespacedReference `json:"eventOrchestrationRef,omitempty" tf:"-"`

	// Selector for a Orchestration in event to populate eventOrchestration.
	// +kubebuilder:validation:Optional
	EventOrchestrationSelector *v1.NamespacedSelector `json:"eventOrchestrationSelector,omitempty" tf:"-"`

	// An Unrouted Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	// +kubebuilder:validation:Optional
	Set []OrchestrationUnroutedSetParameters `json:"set,omitempty" tf:"set,omitempty"`
}

type OrchestrationUnroutedSetInitParameters struct {

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The Unrouted Orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions.
	Rule []OrchestrationUnroutedSetRuleInitParameters `json:"rule,omitempty" tf:"rule,omitempty"`
}

type OrchestrationUnroutedSetObservation struct {

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The Unrouted Orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions.
	Rule []OrchestrationUnroutedSetRuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`
}

type OrchestrationUnroutedSetParameters struct {

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`

	// The Unrouted Orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions.
	// +kubebuilder:validation:Optional
	Rule []OrchestrationUnroutedSetRuleParameters `json:"rule,omitempty" tf:"rule,omitempty"`
}

type OrchestrationUnroutedSetRuleActionsInitParameters struct {

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	Extraction []SetRuleActionsExtractionInitParameters `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
	RouteTo *string `json:"routeTo,omitempty" tf:"route_to,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	Variable []SetRuleActionsVariableInitParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type OrchestrationUnroutedSetRuleActionsObservation struct {

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	Extraction []SetRuleActionsExtractionObservation `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
	RouteTo *string `json:"routeTo,omitempty" tf:"route_to,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	Variable []SetRuleActionsVariableObservation `json:"variable,omitempty" tf:"variable,omitempty"`
}

type OrchestrationUnroutedSetRuleActionsParameters struct {

	// sets whether the resulting alert status is trigger or resolve. Allowed values are: trigger, resolve
	// +kubebuilder:validation:Optional
	EventAction *string `json:"eventAction,omitempty" tf:"event_action,omitempty"`

	// Replace any CEF field or Custom Details object field using custom variables.
	// +kubebuilder:validation:Optional
	Extraction []SetRuleActionsExtractionParameters `json:"extraction,omitempty" tf:"extraction,omitempty"`

	// The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
	// +kubebuilder:validation:Optional
	RouteTo *string `json:"routeTo,omitempty" tf:"route_to,omitempty"`

	// sets Severity of the resulting alert. Allowed values are: info, error, warning, critical
	// +kubebuilder:validation:Optional
	Severity *string `json:"severity,omitempty" tf:"severity,omitempty"`

	// Populate variables from event payloads and use those variables in other event actions.
	// +kubebuilder:validation:Optional
	Variable []SetRuleActionsVariableParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type OrchestrationUnroutedSetRuleConditionInitParameters struct {

	// A PCL condition string.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`
}

type OrchestrationUnroutedSetRuleConditionObservation struct {

	// A PCL condition string.
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`
}

type OrchestrationUnroutedSetRuleConditionParameters struct {

	// A PCL condition string.
	// +kubebuilder:validation:Optional
	Expression *string `json:"expression" tf:"expression,omitempty"`
}

type OrchestrationUnroutedSetRuleInitParameters struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	Actions []OrchestrationUnroutedSetRuleActionsInitParameters `json:"actions,omitempty" tf:"actions,omitempty"`

	// Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will always match against the rule.
	Condition []OrchestrationUnroutedSetRuleConditionInitParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// Indicates whether the rule is disabled and would therefore not be evaluated.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// A description of this rule's purpose.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type OrchestrationUnroutedSetRuleObservation struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	Actions []OrchestrationUnroutedSetRuleActionsObservation `json:"actions,omitempty" tf:"actions,omitempty"`

	// Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will always match against the rule.
	Condition []OrchestrationUnroutedSetRuleConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`

	// Indicates whether the rule is disabled and would therefore not be evaluated.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// The ID of this set of rules. Rules in other sets can route events into this set using the rule's route_to property.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// A description of this rule's purpose.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type OrchestrationUnroutedSetRuleParameters struct {

	// Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
	// +kubebuilder:validation:Optional
	Actions []OrchestrationUnroutedSetRuleActionsParameters `json:"actions" tf:"actions,omitempty"`

	// Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will always match against the rule.
	// +kubebuilder:validation:Optional
	Condition []OrchestrationUnroutedSetRuleConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// Indicates whether the rule is disabled and would therefore not be evaluated.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// A description of this rule's purpose.
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`
}

type SetRuleActionsExtractionInitParameters struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type SetRuleActionsExtractionObservation struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type SetRuleActionsExtractionParameters struct {

	// A RE2 regular expression that will be matched against field specified via the source argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// The path to the event field where the regex will be applied to extract a value. You can use any valid PCL path like event.summary and you can reference previously-defined variables using a path like variables.hostname. This field can be ignored for template based extractions.
	// +kubebuilder:validation:Optional
	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	// The PagerDuty Common Event Format PD-CEF field that will be set with the value from the template or based on regex and source fields.
	// +kubebuilder:validation:Optional
	Target *string `json:"target" tf:"target,omitempty"`

	// A string that will be used to populate the target field. You can reference variables or event data within your template using double curly braces. For example:
	// +kubebuilder:validation:Optional
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type SetRuleActionsVariableInitParameters struct {

	// The name of the variable
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Only regex is supported
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The Regex expression to match against. Must use valid RE2 regular expression syntax.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SetRuleActionsVariableObservation struct {

	// The name of the variable
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Only regex is supported
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The Regex expression to match against. Must use valid RE2 regular expression syntax.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SetRuleActionsVariableParameters struct {

	// The name of the variable
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// Path to a field in an event, in dot-notation. This supports both PD-CEF and non-CEF fields. Eg: Use event.summary for the summary CEF field. Use raw_event.fieldname to read from the original event fieldname data.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// Only regex is supported
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`

	// The Regex expression to match against. Must use valid RE2 regular expression syntax.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

// OrchestrationUnroutedSpec defines the desired state of OrchestrationUnrouted
type OrchestrationUnroutedSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            OrchestrationUnroutedParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider OrchestrationUnroutedInitParameters `json:"initProvider,omitempty"`
}

// OrchestrationUnroutedStatus defines the observed state of OrchestrationUnrouted.
type OrchestrationUnroutedStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OrchestrationUnroutedObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// OrchestrationUnrouted is the Schema for the OrchestrationUnrouteds API. Creates and manages an Unrouted Orchestration for a Global Event Orchestration in PagerDuty.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,pagerduty}
type OrchestrationUnrouted struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.catchAll) || (has(self.initProvider) && has(self.initProvider.catchAll))",message="spec.forProvider.catchAll is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.set) || (has(self.initProvider) && has(self.initProvider.set))",message="spec.forProvider.set is a required parameter"
	Spec   OrchestrationUnroutedSpec   `json:"spec"`
	Status OrchestrationUnroutedStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OrchestrationUnroutedList contains a list of OrchestrationUnrouteds
type OrchestrationUnroutedList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OrchestrationUnrouted `json:"items"`
}

// Repository type metadata.
var (
	OrchestrationUnrouted_Kind             = "OrchestrationUnrouted"
	OrchestrationUnrouted_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OrchestrationUnrouted_Kind}.String()
	OrchestrationUnrouted_KindAPIVersion   = OrchestrationUnrouted_Kind + "." + CRDGroupVersion.String()
	OrchestrationUnrouted_GroupVersionKind = CRDGroupVersion.WithKind(OrchestrationUnrouted_Kind)
)

func init() {
	SchemeBuilder.Register(&OrchestrationUnrouted{}, &OrchestrationUnroutedList{})
}
